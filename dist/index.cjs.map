{"version":3,"sources":["../src/index.ts","../src/runner.ts","../src/worker.ts"],"sourcesContent":["// Copyright (c) 2020-2022 Climate Interactive / New Venture Fund\n\nexport { spawnAsyncModelRunner } from './runner'\n\nexport { exposeModelWorker } from './worker'\n","// Copyright (c) 2020-2022 Climate Interactive / New Venture Fund\n\nimport { BlobWorker, spawn, Thread, Transfer, Worker } from 'threads'\n\nimport type { ModelRunner } from '@sdeverywhere/runtime'\nimport { Outputs, updateOutputIndices } from '@sdeverywhere/runtime'\n\n/**\n * Initialize a `ModelRunner` that runs the model asynchronously in a worker thread.\n *\n * In your app project, define a JavaScript file, called `worker.js` for example, that\n * initializes the model worker in the context of the Web Worker:\n *\n * ```js\n * import { initWasmModelAndBuffers } from '@sdeverywhere/runtime'\n * import { exposeModelWorker } from '@sdeverywhere/runtime-async/worker'\n *\n * async function initWasmModel() {\n *   const wasmModules = loadWasm()\n *   return initWasmModelAndBuffers(...)\n * }\n *\n * exposeModelWorker(initWasmModel)\n * ```\n *\n * Then, in your web app, call the `spawnAsyncModelRunner` function, which\n * will spawn the Web Worker and initialize the `ModelRunner` that communicates\n * with the worker:\n *\n * ```js\n * import { spawnAsyncModelRunner } from '@sdeverywhere/runtime-async/runner'\n *\n * async function initApp() {\n *   // ...\n *   const runner = await spawnAsyncModelRunner({ path: './worker.js' })\n *   // ...\n * }\n * ```\n *\n * @param workerSpec Either a `path` to the worker JavaScript file, or the `source`\n * containing the full JavaScript source of the worker.\n */\nexport async function spawnAsyncModelRunner(workerSpec: { path: string } | { source: string }): Promise<ModelRunner> {\n  if (workerSpec['path']) {\n    return spawnAsyncModelRunnerWithWorker(new Worker(workerSpec['path']))\n  } else {\n    return spawnAsyncModelRunnerWithWorker(BlobWorker.fromText(workerSpec['source']))\n  }\n}\n\n/**\n * @hidden For internal use only\n */\nasync function spawnAsyncModelRunnerWithWorker(worker: Worker): Promise<ModelRunner> {\n  // Spawn the given Worker that contains the `ModelWorker`\n  const modelWorker = await spawn(worker)\n\n  // Wait for the worker to initialize the wasm model (in the worker thread)\n  const initResult = await modelWorker.initModel()\n  let ioBuffer: ArrayBuffer = initResult.ioBuffer\n\n  // The run time is stored in the first 8 bytes of the shared buffer\n  const runTimeOffsetInBytes = 0\n  const runTimeLengthInElements = 1\n  const runTimeLengthInBytes = runTimeLengthInElements * 8\n\n  // The inputs are stored after the run time in the shared buffer\n  const inputsOffsetInBytes = runTimeOffsetInBytes + runTimeLengthInBytes\n  const inputsLengthInElements: number = initResult.inputsLength\n  const inputsLengthInBytes = inputsLengthInElements * 8\n\n  // The outputs are stored after the inputs in the shared buffer\n  const outputsOffsetInBytes = inputsOffsetInBytes + inputsLengthInBytes\n  const outputsLengthInElements: number = initResult.outputsLength\n  const outputsLengthInBytes = outputsLengthInElements * 8\n\n  // The output indices are (optionally) stored after the outputs in the shared buffer\n  const indicesOffsetInBytes = outputsOffsetInBytes + outputsLengthInBytes\n  const indicesLengthInElements: number = initResult.outputIndicesLength\n\n  // The row length is the number of elements in each row of the outputs buffer\n  const outputRowLength: number = initResult.outputRowLength\n\n  // Use a flag to ensure that only one request is made at a time\n  let running = false\n\n  // Disallow `runModel` after the runner has been terminated\n  let terminated = false\n\n  return {\n    createOutputs: () => {\n      return new Outputs(initResult.outputVarIds, initResult.startTime, initResult.endTime, initResult.saveFreq)\n    },\n\n    runModel: async (inputs, outputs) => {\n      if (terminated) {\n        throw new Error('Async model runner has already been terminated')\n      } else if (running) {\n        throw new Error('Async model runner only supports one `runModel` call at a time')\n      } else {\n        running = true\n      }\n\n      // Capture the current set of input values into the reusable buffer\n      const inputsArray = new Float64Array(ioBuffer, inputsOffsetInBytes, inputsLengthInElements)\n      for (let i = 0; i < inputs.length; i++) {\n        inputsArray[i] = inputs[i].get()\n      }\n\n      // Update the output indices, if needed\n      if (indicesLengthInElements > 0) {\n        const outputSpecs = outputs.varSpecs || []\n        const indicesArray = new Int32Array(ioBuffer, indicesOffsetInBytes, indicesLengthInElements)\n        updateOutputIndices(indicesArray, outputSpecs)\n      }\n\n      // Run the model in the worker. We pass the underlying `ArrayBuffer`\n      // instance back to the worker wrapped in a `Transfer` to make it\n      // no-copy transferable, and then the worker will return it back\n      // to us.\n      try {\n        ioBuffer = await modelWorker.runModel(Transfer(ioBuffer))\n      } finally {\n        running = false\n      }\n\n      // Save the model run time\n      const runTimeArray = new Float64Array(ioBuffer, runTimeOffsetInBytes, runTimeLengthInElements)\n      outputs.runTimeInMillis = runTimeArray[0]\n\n      // Capture the outputs array by copying the data into the given `Outputs`\n      // data structure\n      const outputsArray = new Float64Array(ioBuffer, outputsOffsetInBytes, outputsLengthInElements)\n      outputs.updateFromBuffer(outputsArray, outputRowLength)\n\n      return outputs\n    },\n\n    terminate: () => {\n      if (terminated) {\n        return Promise.resolve()\n      } else {\n        terminated = true\n        return Thread.terminate(modelWorker)\n      }\n    }\n  }\n}\n","// Copyright (c) 2020-2022 Climate Interactive / New Venture Fund\n\nimport type { TransferDescriptor } from 'threads'\nimport { expose, Transfer } from 'threads/worker'\n\nimport type { WasmBuffer, WasmModel, WasmModelInitResult } from '@sdeverywhere/runtime'\nimport { perfElapsed, perfNow } from '@sdeverywhere/runtime'\n\n/** @hidden */\nlet initWasmModel: () => Promise<WasmModelInitResult>\n/** @hidden */\nlet wasmModel: WasmModel\n/** @hidden */\nlet inputsWasmBuffer: WasmBuffer<Float64Array>\n/** @hidden */\nlet outputsWasmBuffer: WasmBuffer<Float64Array>\n/** @hidden */\nlet outputIndicesWasmBuffer: WasmBuffer<Int32Array>\n\ninterface InitResult {\n  outputVarIds: string[]\n  startTime: number\n  endTime: number\n  saveFreq: number\n  inputsLength: number\n  outputsLength: number\n  outputIndicesLength: number\n  outputRowLength: number\n  ioBuffer: ArrayBuffer\n}\n\n/** @hidden */\nconst modelWorker = {\n  async initModel(): Promise<TransferDescriptor<InitResult>> {\n    if (wasmModel) {\n      throw new Error('WasmModel was already initialized')\n    }\n\n    // Initialize the wasm model and associated buffers\n    const wasmResult = await initWasmModel()\n\n    // Capture the `WasmModel` instance and `WasmBuffer` instances\n    wasmModel = wasmResult.model\n    inputsWasmBuffer = wasmResult.inputsBuffer\n    outputsWasmBuffer = wasmResult.outputsBuffer\n    outputIndicesWasmBuffer = wasmResult.outputIndicesBuffer\n\n    // Create a combined array that will hold a copy of the inputs and outputs\n    // wasm buffers; this buffer is no-copy transferable, whereas the wasm ones\n    // are not allowed to be transferred\n    const runTimeLength = 8\n    const inputsLength = inputsWasmBuffer.getArrayView().length\n    const outputsLength = outputsWasmBuffer.getArrayView().length\n    const outputIndicesLength = outputIndicesWasmBuffer?.getArrayView().length || 0\n    const totalLength = runTimeLength + inputsLength + outputsLength + outputIndicesLength\n    const ioArray = new Float64Array(totalLength)\n\n    // Transfer the underlying buffer to the runner\n    const ioBuffer = ioArray.buffer\n    const initResult: InitResult = {\n      outputVarIds: wasmResult.outputVarIds,\n      startTime: wasmModel.startTime,\n      endTime: wasmModel.endTime,\n      saveFreq: wasmModel.saveFreq,\n      inputsLength,\n      outputsLength,\n      outputIndicesLength,\n      outputRowLength: wasmModel.numSavePoints,\n      ioBuffer\n    }\n    return Transfer(initResult, [ioBuffer])\n  },\n\n  runModel(ioBuffer: ArrayBuffer): TransferDescriptor<ArrayBuffer> {\n    if (!wasmModel) {\n      throw new Error('WasmModel must be initialized before running the model in worker')\n    }\n\n    // The run time is stored in the first 8 bytes\n    const runTimeOffsetInBytes = 0\n    const runTimeLengthInElements = 1\n    const runTimeLengthInBytes = runTimeLengthInElements * 8\n\n    // Copy the inputs into the wasm inputs buffer\n    const inputsWasmArray = inputsWasmBuffer.getArrayView()\n    const inputsOffsetInBytes = runTimeOffsetInBytes + runTimeLengthInBytes\n    const inputsLengthInElements = inputsWasmArray.length\n    const inputsLengthInBytes = inputsWasmArray.byteLength\n    const inputsBufferArray = new Float64Array(ioBuffer, inputsOffsetInBytes, inputsLengthInElements)\n    inputsWasmArray.set(inputsBufferArray)\n\n    // Copy the output indices into the wasm buffer, if needed\n    const outputsWasmArray = outputsWasmBuffer.getArrayView()\n    const outputsOffsetInBytes = runTimeLengthInBytes + inputsLengthInBytes\n    const outputsLengthInBytes = outputsWasmArray.byteLength\n    let useIndices = false\n    if (outputIndicesWasmBuffer) {\n      const indicesWasmArray = outputIndicesWasmBuffer.getArrayView()\n      const indicesLengthInElements = indicesWasmArray.length\n      const indicesOffsetInBytes = outputsOffsetInBytes + outputsLengthInBytes\n      const indicesBufferArray = new Int32Array(ioBuffer, indicesOffsetInBytes, indicesLengthInElements)\n      if (indicesBufferArray[0] !== 0) {\n        // Only use the indices if the first index is non-zero\n        indicesWasmArray.set(indicesBufferArray)\n        useIndices = true\n      }\n    }\n\n    // Run the model using the wasm buffers\n    const t0 = perfNow()\n    wasmModel.runModel(inputsWasmBuffer, outputsWasmBuffer, useIndices ? outputIndicesWasmBuffer : undefined)\n    const elapsed = perfElapsed(t0)\n\n    // Write the model run time to the buffer\n    const runTimeBufferArray = new Float64Array(ioBuffer, runTimeOffsetInBytes, runTimeLengthInElements)\n    runTimeBufferArray[0] = elapsed\n\n    // Copy the outputs from the wasm outputs buffer\n    const outputsLengthInElements = outputsWasmArray.length\n    const outputsBufferArray = new Float64Array(ioBuffer, outputsOffsetInBytes, outputsLengthInElements)\n    outputsBufferArray.set(outputsWasmArray)\n\n    // Transfer the buffer back to the runner\n    return Transfer(ioBuffer)\n  }\n}\n\n/**\n * Expose an object in the current worker thread that communicates with the\n * `ModelRunner` instance running in the main thread.  The exposed worker\n * object will take care of running the `WasmModel` on the worker thread\n * and sending the outputs back to the main process.\n *\n * @param init The function that initializes the `WasmModel` instance that\n * is used in the worker thread.\n */\nexport function exposeModelWorker(init: () => Promise<WasmModelInitResult>): void {\n  // Save the initializer, which will be used when the runner calls `initModel`\n  // on the worker\n  initWasmModel = init\n\n  // Expose the worker implementation to `threads.js`\n  expose(modelWorker)\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEA,qBAA4D;AAG5D,qBAA6C;AAqC7C,eAAsB,sBAAsB,YAAyE;AACnH,MAAI,WAAW,SAAS;AACtB,WAAO,gCAAgC,IAAI,sBAAO,WAAW,OAAO,CAAC;AAAA,EACvE,OAAO;AACL,WAAO,gCAAgC,0BAAW,SAAS,WAAW,SAAS,CAAC;AAAA,EAClF;AACF;AAKA,eAAe,gCAAgC,QAAsC;AAEnF,QAAMA,eAAc,UAAM,sBAAM,MAAM;AAGtC,QAAM,aAAa,MAAMA,aAAY,UAAU;AAC/C,MAAI,WAAwB,WAAW;AAGvC,QAAM,uBAAuB;AAC7B,QAAM,0BAA0B;AAChC,QAAM,uBAAuB,0BAA0B;AAGvD,QAAM,sBAAsB,uBAAuB;AACnD,QAAM,yBAAiC,WAAW;AAClD,QAAM,sBAAsB,yBAAyB;AAGrD,QAAM,uBAAuB,sBAAsB;AACnD,QAAM,0BAAkC,WAAW;AACnD,QAAM,uBAAuB,0BAA0B;AAGvD,QAAM,uBAAuB,uBAAuB;AACpD,QAAM,0BAAkC,WAAW;AAGnD,QAAM,kBAA0B,WAAW;AAG3C,MAAI,UAAU;AAGd,MAAI,aAAa;AAEjB,SAAO;AAAA,IACL,eAAe,MAAM;AACnB,aAAO,IAAI,uBAAQ,WAAW,cAAc,WAAW,WAAW,WAAW,SAAS,WAAW,QAAQ;AAAA,IAC3G;AAAA,IAEA,UAAU,OAAO,QAAQ,YAAY;AACnC,UAAI,YAAY;AACd,cAAM,IAAI,MAAM,gDAAgD;AAAA,MAClE,WAAW,SAAS;AAClB,cAAM,IAAI,MAAM,gEAAgE;AAAA,MAClF,OAAO;AACL,kBAAU;AAAA,MACZ;AAGA,YAAM,cAAc,IAAI,aAAa,UAAU,qBAAqB,sBAAsB;AAC1F,eAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,oBAAY,KAAK,OAAO,GAAG,IAAI;AAAA,MACjC;AAGA,UAAI,0BAA0B,GAAG;AAC/B,cAAM,cAAc,QAAQ,YAAY,CAAC;AACzC,cAAM,eAAe,IAAI,WAAW,UAAU,sBAAsB,uBAAuB;AAC3F,gDAAoB,cAAc,WAAW;AAAA,MAC/C;AAMA,UAAI;AACF,mBAAW,MAAMA,aAAY,aAAS,yBAAS,QAAQ,CAAC;AAAA,MAC1D,UAAE;AACA,kBAAU;AAAA,MACZ;AAGA,YAAM,eAAe,IAAI,aAAa,UAAU,sBAAsB,uBAAuB;AAC7F,cAAQ,kBAAkB,aAAa;AAIvC,YAAM,eAAe,IAAI,aAAa,UAAU,sBAAsB,uBAAuB;AAC7F,cAAQ,iBAAiB,cAAc,eAAe;AAEtD,aAAO;AAAA,IACT;AAAA,IAEA,WAAW,MAAM;AACf,UAAI,YAAY;AACd,eAAO,QAAQ,QAAQ;AAAA,MACzB,OAAO;AACL,qBAAa;AACb,eAAO,sBAAO,UAAUA,YAAW;AAAA,MACrC;AAAA,IACF;AAAA,EACF;AACF;;;AChJA,oBAAiC;AAGjC,IAAAC,kBAAqC;AAGrC,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAeJ,IAAM,cAAc;AAAA,EAClB,MAAM,YAAqD;AACzD,QAAI,WAAW;AACb,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACrD;AAGA,UAAM,aAAa,MAAM,cAAc;AAGvC,gBAAY,WAAW;AACvB,uBAAmB,WAAW;AAC9B,wBAAoB,WAAW;AAC/B,8BAA0B,WAAW;AAKrC,UAAM,gBAAgB;AACtB,UAAM,eAAe,iBAAiB,aAAa,EAAE;AACrD,UAAM,gBAAgB,kBAAkB,aAAa,EAAE;AACvD,UAAM,uBAAsB,mEAAyB,eAAe,WAAU;AAC9E,UAAM,cAAc,gBAAgB,eAAe,gBAAgB;AACnE,UAAM,UAAU,IAAI,aAAa,WAAW;AAG5C,UAAM,WAAW,QAAQ;AACzB,UAAM,aAAyB;AAAA,MAC7B,cAAc,WAAW;AAAA,MACzB,WAAW,UAAU;AAAA,MACrB,SAAS,UAAU;AAAA,MACnB,UAAU,UAAU;AAAA,MACpB;AAAA,MACA;AAAA,MACA;AAAA,MACA,iBAAiB,UAAU;AAAA,MAC3B;AAAA,IACF;AACA,eAAO,wBAAS,YAAY,CAAC,QAAQ,CAAC;AAAA,EACxC;AAAA,EAEA,SAAS,UAAwD;AAC/D,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,MAAM,kEAAkE;AAAA,IACpF;AAGA,UAAM,uBAAuB;AAC7B,UAAM,0BAA0B;AAChC,UAAM,uBAAuB,0BAA0B;AAGvD,UAAM,kBAAkB,iBAAiB,aAAa;AACtD,UAAM,sBAAsB,uBAAuB;AACnD,UAAM,yBAAyB,gBAAgB;AAC/C,UAAM,sBAAsB,gBAAgB;AAC5C,UAAM,oBAAoB,IAAI,aAAa,UAAU,qBAAqB,sBAAsB;AAChG,oBAAgB,IAAI,iBAAiB;AAGrC,UAAM,mBAAmB,kBAAkB,aAAa;AACxD,UAAM,uBAAuB,uBAAuB;AACpD,UAAM,uBAAuB,iBAAiB;AAC9C,QAAI,aAAa;AACjB,QAAI,yBAAyB;AAC3B,YAAM,mBAAmB,wBAAwB,aAAa;AAC9D,YAAM,0BAA0B,iBAAiB;AACjD,YAAM,uBAAuB,uBAAuB;AACpD,YAAM,qBAAqB,IAAI,WAAW,UAAU,sBAAsB,uBAAuB;AACjG,UAAI,mBAAmB,OAAO,GAAG;AAE/B,yBAAiB,IAAI,kBAAkB;AACvC,qBAAa;AAAA,MACf;AAAA,IACF;AAGA,UAAM,SAAK,yBAAQ;AACnB,cAAU,SAAS,kBAAkB,mBAAmB,aAAa,0BAA0B,MAAS;AACxG,UAAM,cAAU,6BAAY,EAAE;AAG9B,UAAM,qBAAqB,IAAI,aAAa,UAAU,sBAAsB,uBAAuB;AACnG,uBAAmB,KAAK;AAGxB,UAAM,0BAA0B,iBAAiB;AACjD,UAAM,qBAAqB,IAAI,aAAa,UAAU,sBAAsB,uBAAuB;AACnG,uBAAmB,IAAI,gBAAgB;AAGvC,eAAO,wBAAS,QAAQ;AAAA,EAC1B;AACF;AAWO,SAAS,kBAAkB,MAAgD;AAGhF,kBAAgB;AAGhB,4BAAO,WAAW;AACpB;","names":["modelWorker","import_runtime"]}