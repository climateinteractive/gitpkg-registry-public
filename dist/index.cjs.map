{"version":3,"sources":["../src/index.ts","../../../node_modules/.pnpm/tsup@7.2.0_typescript@5.2.2/node_modules/tsup/assets/cjs_shims.js","../src/plugin.ts","../src/vite-config.ts","../src/var-names.ts"],"sourcesContent":["// Copyright (c) 2022 Climate Interactive / New Venture Fund\n\nexport type { WorkerPluginOptions } from './options'\nexport { workerPlugin } from './plugin'\n","// Shim globals in cjs bundle\n// There's a weird bug that esbuild will always inject importMetaUrl\n// if we export it as `const importMetaUrl = ... __filename ...`\n// But using a function will not cause this issue\n\nconst getImportMetaUrl = () =>\n  typeof document === 'undefined'\n    ? new URL('file:' + __filename).href\n    : (document.currentScript && document.currentScript.src) ||\n      new URL('main.js', document.baseURI).href\n\nexport const importMetaUrl = /* @__PURE__ */ getImportMetaUrl()\n","// Copyright (c) 2022 Climate Interactive / New Venture Fund\n\nimport { basename, dirname, join as joinPath } from 'path'\n\nimport { build } from 'vite'\n\nimport type { BuildContext, ModelSpec, Plugin } from '@sdeverywhere/build'\n\nimport type { WorkerPluginOptions } from './options'\nimport { createViteConfig } from './vite-config'\n\nexport function workerPlugin(options?: WorkerPluginOptions): Plugin {\n  return new WorkerPlugin(options)\n}\n\nclass WorkerPlugin implements Plugin {\n  constructor(private readonly options?: WorkerPluginOptions) {}\n\n  async postGenerate(context: BuildContext, modelSpec: ModelSpec): Promise<boolean> {\n    const log = context.log\n    log('info', 'Building worker')\n\n    // Locate the input (model JS/Wasm) file in the staged directory.  Note\n    // that this relies on the `plugin-wasm` package writing a file called\n    // `wasm-model.js` to the `staged/model` directory.\n    const prepDir = context.config.prepDir\n    const srcDir = 'model'\n    const stagedModelDir = joinPath(prepDir, 'staged', srcDir)\n    const inModelJsFile = 'wasm-model.js'\n    const outWorkerJsFile = 'worker.js'\n\n    // If `outputPaths` is undefined, write the `worker.js` to the prep dir\n    const outputPaths = this.options?.outputPaths || [joinPath(prepDir, outWorkerJsFile)]\n\n    // Add staged file entries; this will cause the generated worker to be copied\n    // to the configured output paths during the \"copy staged files\" step\n    // TODO: This assumes that other plugins that use the generated worker files\n    // will run after the \"copy staged files\" step.  There might be use cases\n    // where a plugin needs access to these in `postGenerate`, in which case the\n    // files will not have been copied already.  Need to reconsider the ordering\n    // of plugins and the \"copy staged files\" step(s).\n    for (const outputPath of outputPaths) {\n      const dstDir = dirname(outputPath)\n      const dstFile = basename(outputPath)\n      context.prepareStagedFile(srcDir, outWorkerJsFile, dstDir, dstFile)\n    }\n\n    // Build the worker and write generated file to the `staged/model` directory\n    const viteConfig = createViteConfig(stagedModelDir, inModelJsFile, modelSpec, outWorkerJsFile)\n    await build(viteConfig)\n\n    // log('info', 'Done!')\n\n    return true\n  }\n}\n","// Copyright (c) 2022 Climate Interactive / New Venture Fund\n\nimport { dirname, resolve as resolvePath } from 'path'\nimport { fileURLToPath } from 'url'\n\nimport type { InlineConfig, Plugin as VitePlugin } from 'vite'\n\nimport type { ModelSpec } from '@sdeverywhere/build'\n\nimport { sdeNameForVensimVarName } from './var-names'\n\nconst __filename = fileURLToPath(import.meta.url)\nconst __dirname = dirname(__filename)\n\n/**\n * This is a virtual module plugin used to inject model-specific configuration\n * values into the generated worker bundle.\n *\n * This follows the \"Virtual Modules Convention\" described here:\n *   https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention\n *\n * TODO: This could be simplified by using `vite-plugin-virtual` but that\n * doesn't seem to be working correctly in an ESM setting\n */\nfunction injectModelSpec(modelSpec: ModelSpec): VitePlugin {\n  const outputVarIds = modelSpec.outputs.map(o => sdeNameForVensimVarName(o.varName))\n\n  const moduleSrc = `\nexport const numInputs = ${modelSpec.inputs.length};\nexport const outputVarIds = ${JSON.stringify(outputVarIds)};\n`\n\n  const virtualModuleId = 'virtual:model-spec'\n  const resolvedVirtualModuleId = '\\0' + virtualModuleId\n\n  return {\n    name: 'vite-plugin-virtual-custom',\n    resolveId(id: string) {\n      if (id === virtualModuleId) {\n        return resolvedVirtualModuleId\n      }\n    },\n    load(id: string) {\n      if (id === resolvedVirtualModuleId) {\n        return moduleSrc\n      }\n    }\n  }\n}\n\n/**\n * Create a Vite `InlineConfig` that can be used to build a complete\n * worker bundle that can run the generated Wasm model in a separate\n * Web Worker or Node worker thread.\n *\n * @param stagedModelDir The `staged` directory under the `sde-prep` directory.\n * @param modelJsFile The name of the JS file containing the embedded Wasm.\n * @param modelSpec The model spec generated earlier in the build process.\n * @param outputFile The name of the generated worker JS file.\n * @return An `InlineConfig` instance that can be passed to Vite's `build` function.\n */\nexport function createViteConfig(\n  stagedModelDir: string,\n  modelJsFile: string,\n  modelSpec: ModelSpec,\n  outputFile: string\n): InlineConfig {\n  // Use `staged/model` as the root directory for the worker build\n  const root = stagedModelDir\n\n  // Use `template-worker/worker.js` from this package as the entry file\n  const entry = resolvePath(__dirname, '..', 'template-worker', 'worker.js')\n\n  return {\n    // Don't use an external config file\n    configFile: false,\n\n    // Use the root directory configured above\n    root,\n\n    // Don't clear the screen in dev mode so that we can see builder output\n    clearScreen: false,\n\n    // Disable vite output by default\n    // TODO: Re-enable logging if `--verbose` option is used?\n    logLevel: 'silent',\n\n    // Configure path aliases\n    resolve: {\n      alias: [\n        // In the template, we use `@_wasm_` as an alias for the JS-wrapped Wasm\n        // file generated by Emscripten\n        {\n          find: '@_wasm_',\n          replacement: resolvePath(stagedModelDir, modelJsFile)\n        }\n      ],\n\n      // XXX: Prevent Vite from using the `browser` section of `threads/package.json`\n      // since we want to force the use of the general module (under dist) that chooses\n      // the correct implementation (Web Worker vs worker_threads) at runtime.  This\n      // gets the job done, but is fragile because it applies to all dependencies even\n      // though we really only need this workaround for the threads package.  Fortunately\n      // the worker template is very simple (only depends on `@sdeverywhere/runtime-async`,\n      // which in turn only depends on `@sdeverywhere/runtime` and `threads`, so we should\n      // be safe to use this workaround for a while.\n      browserField: false\n    },\n\n    plugins: [\n      // Use a virtual module plugin to inject the model spec values\n      injectModelSpec(modelSpec)\n    ],\n\n    build: {\n      // Write output file to the `staged/model` directory; note that this path is\n      // relative to the bundle `root` directory\n      outDir: '.',\n      emptyOutDir: false,\n\n      lib: {\n        entry,\n        name: 'worker',\n        formats: ['iife'],\n        fileName: () => outputFile\n      },\n\n      rollupOptions: {\n        onwarn: (warning, warn) => {\n          // XXX: Suppress \"Use of eval is strongly discouraged\" warnings that are\n          // triggered by use of the following pattern in threads.js:\n          //   eval(\"require\")(\"worker_threads\")\n          // It would be nice to avoid use of `eval` there, but it's not critical for\n          // our use case so we will suppress the warnings for now\n          if (warning.code !== 'EVAL') {\n            warn(warning)\n          }\n        }\n      }\n    }\n  }\n}\n","// Copyright (c) 2022 Climate Interactive / New Venture Fund\n\n/**\n * Helper function that converts a Vensim variable or subscript name\n * into a valid C identifier as used by SDE.\n * TODO: Import helper function from `compile` package instead\n */\nfunction sdeNameForVensimName(name: string): string {\n  return (\n    '_' +\n    name\n      .trim()\n      .replace(/\"/g, '_')\n      .replace(/\\s+!$/g, '!')\n      .replace(/\\s/g, '_')\n      .replace(/,/g, '_')\n      .replace(/-/g, '_')\n      .replace(/\\./g, '_')\n      .replace(/\\$/g, '_')\n      .replace(/'/g, '_')\n      .replace(/&/g, '_')\n      .replace(/%/g, '_')\n      .replace(/\\//g, '_')\n      .replace(/\\|/g, '_')\n      .toLowerCase()\n  )\n}\n\n/**\n * Helper function that converts a Vensim variable name (possibly containing\n * subscripts) into a valid C identifier as used by SDE.\n * TODO: Import helper function from `compile` package instead\n */\nexport function sdeNameForVensimVarName(varName: string): string {\n  const m = varName.match(/([^[]+)(?:\\[([^\\]]+)\\])?/)\n  if (!m) {\n    throw new Error(`Invalid Vensim name: ${varName}`)\n  }\n  let id = sdeNameForVensimName(m[1])\n  if (m[2]) {\n    const subscripts = m[2].split(',').map(x => sdeNameForVensimName(x))\n    id += `[${subscripts.join('][')}]`\n  }\n\n  return id\n}\n"],"mappings":"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","names":["import_path","__filename","resolvePath","joinPath"]}