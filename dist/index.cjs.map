{"version":3,"sources":["../src/index.ts","../src/plugin.ts"],"sourcesContent":["// Copyright (c) 2022 Climate Interactive / New Venture Fund\n\nexport type { WasmPluginOptions } from './options'\nexport { wasmPlugin } from './plugin'\n","// Copyright (c) 2022 Climate Interactive / New Venture Fund\n\nimport { existsSync } from 'fs'\nimport { basename, dirname, join as joinPath } from 'path'\n\nimport { findUp } from 'find-up'\n\nimport type { BuildContext, Plugin } from '@sdeverywhere/build'\n\nimport type { WasmPluginOptions } from './options'\n\nexport function wasmPlugin(options?: WasmPluginOptions): Plugin {\n  return new WasmPlugin(options)\n}\n\nclass WasmPlugin implements Plugin {\n  constructor(private readonly options?: WasmPluginOptions) {}\n\n  async postGenerateC(context: BuildContext, cContent: string): Promise<string> {\n    context.log('info', '  Generating WebAssembly module')\n\n    // Locate the Emscripten SDK directory\n    let emsdkDir: string\n    if (this.options?.emsdkDir) {\n      // Try the configured directory\n      emsdkDir = this.options.emsdkDir\n      if (!existsSync(emsdkDir)) {\n        throw new Error(`Invalid emsdk directory '${emsdkDir}'`)\n      }\n    } else {\n      // Walk up the directory structure to find the nearest `emsdk` directory\n      emsdkDir = await findUp('emsdk', { type: 'directory' })\n      if (emsdkDir === undefined) {\n        throw new Error('Could not find emsdk directory')\n      }\n    }\n\n    // XXX: On Windows, we need to use Windows-specific commands; need to revisit\n    const isWin = process.platform === 'win32'\n    const emccCmd = isWin ? 'emcc.bat' : 'emcc'\n    const emccCmdPath = joinPath(emsdkDir, 'upstream', 'emscripten', emccCmd)\n\n    // If `outputJsPath` is undefined, write `wasm-model.js` to the prep dir\n    const stagedOutputJsFile = 'wasm-model.js'\n    let outputJsPath: string\n    if (this.options?.outputJsPath) {\n      outputJsPath = this.options.outputJsPath\n    } else {\n      outputJsPath = joinPath(context.config.prepDir, stagedOutputJsFile)\n    }\n    const outputJsDir = dirname(outputJsPath)\n    const outputJsFile = basename(outputJsPath)\n\n    // Ensure that the staged directory exists before we build the Wasm model\n    // (otherwise emcc will fail) and add a staged file entry\n    const stagedOutputJsPath = context.prepareStagedFile('model', stagedOutputJsFile, outputJsDir, outputJsFile)\n\n    // Generate the Wasm binary (wrapped in a JS file)\n    await buildWasm(context, emccCmdPath, context.config.prepDir, stagedOutputJsPath)\n\n    // context.log('info', '  Done!')\n\n    return cContent\n  }\n}\n\n/**\n * Generate a JS file (containing an embedded Wasm blob) from the C file.\n */\nasync function buildWasm(\n  context: BuildContext,\n  emccCmdPath: string,\n  prepDir: string,\n  outputJsPath: string\n): Promise<void> {\n  // Use Emscripten to compile the C model into a Wasm blob packaged inside\n  // an ES6 module.  We use `SINGLE_FILE=1` to include the Wasm directly\n  // inside the JS file as a base64-encoded string.  This increases the\n  // total file size by about 30%, but having it bundled makes building\n  // easier and improves startup time (we don't have make a separate fetch\n  // to load it over the network).\n  const command = emccCmdPath\n  const args: string[] = []\n  const addArg = (arg: string) => {\n    args.push(arg)\n  }\n  const addInput = (file: string) => {\n    addArg(`build/${file}`)\n  }\n  const addFlag = (flag: string) => {\n    addArg('-s')\n    addArg(flag)\n  }\n  addInput('processed.c')\n  addInput('macros.c')\n  addInput('model.c')\n  addInput('vensim.c')\n  addArg('-Ibuild')\n  addArg('-o')\n  addArg(outputJsPath)\n  addArg('-Wall')\n  addArg('-Os')\n  addFlag('STRICT=1')\n  addFlag('MALLOC=emmalloc')\n  addFlag('FILESYSTEM=0')\n  addFlag('MODULARIZE=1')\n  addFlag('SINGLE_FILE=1')\n  addFlag('EXPORT_ES6=1')\n  addFlag('USE_ES6_IMPORT_META=0')\n  addFlag(\n    `EXPORTED_FUNCTIONS=['_malloc','_getMaxOutputIndices','_getInitialTime','_getFinalTime','_getSaveper','_runModelWithBuffers']`\n  )\n  addFlag(`EXPORTED_RUNTIME_METHODS=['cwrap']`)\n\n  await context.spawnChild(prepDir, command, args, {\n    // Ignore unhelpful Emscripten SDK cache messages\n    ignoredMessageFilter: 'cache:INFO'\n  })\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEA,gBAA2B;AAC3B,kBAAoD;AAEpD,qBAAuB;AAMhB,SAAS,WAAW,SAAqC;AAC9D,SAAO,IAAI,WAAW,OAAO;AAC/B;AAEA,IAAM,aAAN,MAAmC;AAAA,EACjC,YAA6B,SAA6B;AAA7B;AAAA,EAA8B;AAAA,EAE3D,MAAM,cAAc,SAAuB,UAAmC;AAlBhF;AAmBI,YAAQ,IAAI,QAAQ,iCAAiC;AAGrD,QAAI;AACJ,SAAI,UAAK,YAAL,mBAAc,UAAU;AAE1B,iBAAW,KAAK,QAAQ;AACxB,UAAI,KAAC,sBAAW,QAAQ,GAAG;AACzB,cAAM,IAAI,MAAM,4BAA4B,WAAW;AAAA,MACzD;AAAA,IACF,OAAO;AAEL,iBAAW,UAAM,uBAAO,SAAS,EAAE,MAAM,YAAY,CAAC;AACtD,UAAI,aAAa,QAAW;AAC1B,cAAM,IAAI,MAAM,gCAAgC;AAAA,MAClD;AAAA,IACF;AAGA,UAAM,QAAQ,QAAQ,aAAa;AACnC,UAAM,UAAU,QAAQ,aAAa;AACrC,UAAM,kBAAc,YAAAA,MAAS,UAAU,YAAY,cAAc,OAAO;AAGxE,UAAM,qBAAqB;AAC3B,QAAI;AACJ,SAAI,UAAK,YAAL,mBAAc,cAAc;AAC9B,qBAAe,KAAK,QAAQ;AAAA,IAC9B,OAAO;AACL,yBAAe,YAAAA,MAAS,QAAQ,OAAO,SAAS,kBAAkB;AAAA,IACpE;AACA,UAAM,kBAAc,qBAAQ,YAAY;AACxC,UAAM,mBAAe,sBAAS,YAAY;AAI1C,UAAM,qBAAqB,QAAQ,kBAAkB,SAAS,oBAAoB,aAAa,YAAY;AAG3G,UAAM,UAAU,SAAS,aAAa,QAAQ,OAAO,SAAS,kBAAkB;AAIhF,WAAO;AAAA,EACT;AACF;AAKA,eAAe,UACb,SACA,aACA,SACA,cACe;AAOf,QAAM,UAAU;AAChB,QAAM,OAAiB,CAAC;AACxB,QAAM,SAAS,CAAC,QAAgB;AAC9B,SAAK,KAAK,GAAG;AAAA,EACf;AACA,QAAM,WAAW,CAAC,SAAiB;AACjC,WAAO,SAAS,MAAM;AAAA,EACxB;AACA,QAAM,UAAU,CAAC,SAAiB;AAChC,WAAO,IAAI;AACX,WAAO,IAAI;AAAA,EACb;AACA,WAAS,aAAa;AACtB,WAAS,UAAU;AACnB,WAAS,SAAS;AAClB,WAAS,UAAU;AACnB,SAAO,SAAS;AAChB,SAAO,IAAI;AACX,SAAO,YAAY;AACnB,SAAO,OAAO;AACd,SAAO,KAAK;AACZ,UAAQ,UAAU;AAClB,UAAQ,iBAAiB;AACzB,UAAQ,cAAc;AACtB,UAAQ,cAAc;AACtB,UAAQ,eAAe;AACvB,UAAQ,cAAc;AACtB,UAAQ,uBAAuB;AAC/B;AAAA,IACE;AAAA,EACF;AACA,UAAQ,oCAAoC;AAE5C,QAAM,QAAQ,WAAW,SAAS,SAAS,MAAM;AAAA,IAE/C,sBAAsB;AAAA,EACxB,CAAC;AACH;","names":["joinPath"]}