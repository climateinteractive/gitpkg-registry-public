{"version":3,"sources":["../src/runner.ts"],"sourcesContent":["// Copyright (c) 2020-2022 Climate Interactive / New Venture Fund\n\nimport { BlobWorker, spawn, Thread, Transfer, Worker } from 'threads'\n\nimport type { ModelRunner } from '@sdeverywhere/runtime'\nimport { Outputs, updateOutputIndices } from '@sdeverywhere/runtime'\n\n/**\n * Initialize a `ModelRunner` that runs the model asynchronously in a worker thread.\n *\n * In your app project, define a JavaScript file, called `worker.js` for example, that\n * initializes the model worker in the context of the Web Worker:\n *\n * ```js\n * import { initWasmModelAndBuffers } from '@sdeverywhere/runtime'\n * import { exposeModelWorker } from '@sdeverywhere/runtime-async/worker'\n *\n * async function initWasmModel() {\n *   const wasmModules = loadWasm()\n *   return initWasmModelAndBuffers(...)\n * }\n *\n * exposeModelWorker(initWasmModel)\n * ```\n *\n * Then, in your web app, call the `spawnAsyncModelRunner` function, which\n * will spawn the Web Worker and initialize the `ModelRunner` that communicates\n * with the worker:\n *\n * ```js\n * import { spawnAsyncModelRunner } from '@sdeverywhere/runtime-async/runner'\n *\n * async function initApp() {\n *   // ...\n *   const runner = await spawnAsyncModelRunner({ path: './worker.js' })\n *   // ...\n * }\n * ```\n *\n * @param workerSpec Either a `path` to the worker JavaScript file, or the `source`\n * containing the full JavaScript source of the worker.\n */\nexport async function spawnAsyncModelRunner(workerSpec: { path: string } | { source: string }): Promise<ModelRunner> {\n  if (workerSpec['path']) {\n    return spawnAsyncModelRunnerWithWorker(new Worker(workerSpec['path']))\n  } else {\n    return spawnAsyncModelRunnerWithWorker(BlobWorker.fromText(workerSpec['source']))\n  }\n}\n\n/**\n * @hidden For internal use only\n */\nasync function spawnAsyncModelRunnerWithWorker(worker: Worker): Promise<ModelRunner> {\n  // Spawn the given Worker that contains the `ModelWorker`\n  const modelWorker = await spawn(worker)\n\n  // Wait for the worker to initialize the wasm model (in the worker thread)\n  const initResult = await modelWorker.initModel()\n  let ioBuffer: ArrayBuffer = initResult.ioBuffer\n\n  // The run time is stored in the first 8 bytes of the shared buffer\n  const runTimeOffsetInBytes = 0\n  const runTimeLengthInElements = 1\n  const runTimeLengthInBytes = runTimeLengthInElements * 8\n\n  // The inputs are stored after the run time in the shared buffer\n  const inputsOffsetInBytes = runTimeOffsetInBytes + runTimeLengthInBytes\n  const inputsLengthInElements: number = initResult.inputsLength\n  const inputsLengthInBytes = inputsLengthInElements * 8\n\n  // The outputs are stored after the inputs in the shared buffer\n  const outputsOffsetInBytes = inputsOffsetInBytes + inputsLengthInBytes\n  const outputsLengthInElements: number = initResult.outputsLength\n  const outputsLengthInBytes = outputsLengthInElements * 8\n\n  // The output indices are (optionally) stored after the outputs in the shared buffer\n  const indicesOffsetInBytes = outputsOffsetInBytes + outputsLengthInBytes\n  const indicesLengthInElements: number = initResult.outputIndicesLength\n\n  // The row length is the number of elements in each row of the outputs buffer\n  const outputRowLength: number = initResult.outputRowLength\n\n  // Use a flag to ensure that only one request is made at a time\n  let running = false\n\n  // Disallow `runModel` after the runner has been terminated\n  let terminated = false\n\n  return {\n    createOutputs: () => {\n      return new Outputs(initResult.outputVarIds, initResult.startTime, initResult.endTime, initResult.saveFreq)\n    },\n\n    runModel: async (inputs, outputs) => {\n      if (terminated) {\n        throw new Error('Async model runner has already been terminated')\n      } else if (running) {\n        throw new Error('Async model runner only supports one `runModel` call at a time')\n      } else {\n        running = true\n      }\n\n      // Capture the current set of input values into the reusable buffer\n      const inputsArray = new Float64Array(ioBuffer, inputsOffsetInBytes, inputsLengthInElements)\n      for (let i = 0; i < inputs.length; i++) {\n        inputsArray[i] = inputs[i].get()\n      }\n\n      // Update the output indices, if needed\n      if (indicesLengthInElements > 0) {\n        const outputSpecs = outputs.varSpecs || []\n        const indicesArray = new Int32Array(ioBuffer, indicesOffsetInBytes, indicesLengthInElements)\n        updateOutputIndices(indicesArray, outputSpecs)\n      }\n\n      // Run the model in the worker. We pass the underlying `ArrayBuffer`\n      // instance back to the worker wrapped in a `Transfer` to make it\n      // no-copy transferable, and then the worker will return it back\n      // to us.\n      try {\n        ioBuffer = await modelWorker.runModel(Transfer(ioBuffer))\n      } finally {\n        running = false\n      }\n\n      // Save the model run time\n      const runTimeArray = new Float64Array(ioBuffer, runTimeOffsetInBytes, runTimeLengthInElements)\n      outputs.runTimeInMillis = runTimeArray[0]\n\n      // Capture the outputs array by copying the data into the given `Outputs`\n      // data structure\n      const outputsArray = new Float64Array(ioBuffer, outputsOffsetInBytes, outputsLengthInElements)\n      outputs.updateFromBuffer(outputsArray, outputRowLength)\n\n      return outputs\n    },\n\n    terminate: () => {\n      if (terminated) {\n        return Promise.resolve()\n      } else {\n        terminated = true\n        return Thread.terminate(modelWorker)\n      }\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,qBAA4D;AAG5D,qBAA6C;AAqC7C,eAAsB,sBAAsB,YAAyE;AACnH,MAAI,WAAW,SAAS;AACtB,WAAO,gCAAgC,IAAI,sBAAO,WAAW,OAAO,CAAC;AAAA,EACvE,OAAO;AACL,WAAO,gCAAgC,0BAAW,SAAS,WAAW,SAAS,CAAC;AAAA,EAClF;AACF;AAKA,eAAe,gCAAgC,QAAsC;AAEnF,QAAM,cAAc,UAAM,sBAAM,MAAM;AAGtC,QAAM,aAAa,MAAM,YAAY,UAAU;AAC/C,MAAI,WAAwB,WAAW;AAGvC,QAAM,uBAAuB;AAC7B,QAAM,0BAA0B;AAChC,QAAM,uBAAuB,0BAA0B;AAGvD,QAAM,sBAAsB,uBAAuB;AACnD,QAAM,yBAAiC,WAAW;AAClD,QAAM,sBAAsB,yBAAyB;AAGrD,QAAM,uBAAuB,sBAAsB;AACnD,QAAM,0BAAkC,WAAW;AACnD,QAAM,uBAAuB,0BAA0B;AAGvD,QAAM,uBAAuB,uBAAuB;AACpD,QAAM,0BAAkC,WAAW;AAGnD,QAAM,kBAA0B,WAAW;AAG3C,MAAI,UAAU;AAGd,MAAI,aAAa;AAEjB,SAAO;AAAA,IACL,eAAe,MAAM;AACnB,aAAO,IAAI,uBAAQ,WAAW,cAAc,WAAW,WAAW,WAAW,SAAS,WAAW,QAAQ;AAAA,IAC3G;AAAA,IAEA,UAAU,OAAO,QAAQ,YAAY;AACnC,UAAI,YAAY;AACd,cAAM,IAAI,MAAM,gDAAgD;AAAA,MAClE,WAAW,SAAS;AAClB,cAAM,IAAI,MAAM,gEAAgE;AAAA,MAClF,OAAO;AACL,kBAAU;AAAA,MACZ;AAGA,YAAM,cAAc,IAAI,aAAa,UAAU,qBAAqB,sBAAsB;AAC1F,eAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,oBAAY,KAAK,OAAO,GAAG,IAAI;AAAA,MACjC;AAGA,UAAI,0BAA0B,GAAG;AAC/B,cAAM,cAAc,QAAQ,YAAY,CAAC;AACzC,cAAM,eAAe,IAAI,WAAW,UAAU,sBAAsB,uBAAuB;AAC3F,gDAAoB,cAAc,WAAW;AAAA,MAC/C;AAMA,UAAI;AACF,mBAAW,MAAM,YAAY,aAAS,yBAAS,QAAQ,CAAC;AAAA,MAC1D,UAAE;AACA,kBAAU;AAAA,MACZ;AAGA,YAAM,eAAe,IAAI,aAAa,UAAU,sBAAsB,uBAAuB;AAC7F,cAAQ,kBAAkB,aAAa;AAIvC,YAAM,eAAe,IAAI,aAAa,UAAU,sBAAsB,uBAAuB;AAC7F,cAAQ,iBAAiB,cAAc,eAAe;AAEtD,aAAO;AAAA,IACT;AAAA,IAEA,WAAW,MAAM;AACf,UAAI,YAAY;AACd,eAAO,QAAQ,QAAQ;AAAA,MACzB,OAAO;AACL,qBAAa;AACb,eAAO,sBAAO,UAAU,WAAW;AAAA,MACrC;AAAA,IACF;AAAA,EACF;AACF;","names":[]}