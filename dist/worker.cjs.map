{"version":3,"sources":["../src/worker.ts"],"sourcesContent":["// Copyright (c) 2020-2022 Climate Interactive / New Venture Fund\n\nimport type { TransferDescriptor } from 'threads'\nimport { expose, Transfer } from 'threads/worker'\n\nimport type { WasmBuffer, WasmModel, WasmModelInitResult } from '@sdeverywhere/runtime'\nimport { perfElapsed, perfNow } from '@sdeverywhere/runtime'\n\n/** @hidden */\nlet initWasmModel: () => Promise<WasmModelInitResult>\n/** @hidden */\nlet wasmModel: WasmModel\n/** @hidden */\nlet inputsWasmBuffer: WasmBuffer<Float64Array>\n/** @hidden */\nlet outputsWasmBuffer: WasmBuffer<Float64Array>\n/** @hidden */\nlet outputIndicesWasmBuffer: WasmBuffer<Int32Array>\n\ninterface InitResult {\n  outputVarIds: string[]\n  startTime: number\n  endTime: number\n  saveFreq: number\n  inputsLength: number\n  outputsLength: number\n  outputIndicesLength: number\n  outputRowLength: number\n  ioBuffer: ArrayBuffer\n}\n\n/** @hidden */\nconst modelWorker = {\n  async initModel(): Promise<TransferDescriptor<InitResult>> {\n    if (wasmModel) {\n      throw new Error('WasmModel was already initialized')\n    }\n\n    // Initialize the wasm model and associated buffers\n    const wasmResult = await initWasmModel()\n\n    // Capture the `WasmModel` instance and `WasmBuffer` instances\n    wasmModel = wasmResult.model\n    inputsWasmBuffer = wasmResult.inputsBuffer\n    outputsWasmBuffer = wasmResult.outputsBuffer\n    outputIndicesWasmBuffer = wasmResult.outputIndicesBuffer\n\n    // Create a combined array that will hold a copy of the inputs and outputs\n    // wasm buffers; this buffer is no-copy transferable, whereas the wasm ones\n    // are not allowed to be transferred\n    const runTimeLength = 8\n    const inputsLength = inputsWasmBuffer.getArrayView().length\n    const outputsLength = outputsWasmBuffer.getArrayView().length\n    const outputIndicesLength = outputIndicesWasmBuffer?.getArrayView().length || 0\n    const totalLength = runTimeLength + inputsLength + outputsLength + outputIndicesLength\n    const ioArray = new Float64Array(totalLength)\n\n    // Transfer the underlying buffer to the runner\n    const ioBuffer = ioArray.buffer\n    const initResult: InitResult = {\n      outputVarIds: wasmResult.outputVarIds,\n      startTime: wasmModel.startTime,\n      endTime: wasmModel.endTime,\n      saveFreq: wasmModel.saveFreq,\n      inputsLength,\n      outputsLength,\n      outputIndicesLength,\n      outputRowLength: wasmModel.numSavePoints,\n      ioBuffer\n    }\n    return Transfer(initResult, [ioBuffer])\n  },\n\n  runModel(ioBuffer: ArrayBuffer): TransferDescriptor<ArrayBuffer> {\n    if (!wasmModel) {\n      throw new Error('WasmModel must be initialized before running the model in worker')\n    }\n\n    // The run time is stored in the first 8 bytes\n    const runTimeOffsetInBytes = 0\n    const runTimeLengthInElements = 1\n    const runTimeLengthInBytes = runTimeLengthInElements * 8\n\n    // Copy the inputs into the wasm inputs buffer\n    const inputsWasmArray = inputsWasmBuffer.getArrayView()\n    const inputsOffsetInBytes = runTimeOffsetInBytes + runTimeLengthInBytes\n    const inputsLengthInElements = inputsWasmArray.length\n    const inputsLengthInBytes = inputsWasmArray.byteLength\n    const inputsBufferArray = new Float64Array(ioBuffer, inputsOffsetInBytes, inputsLengthInElements)\n    inputsWasmArray.set(inputsBufferArray)\n\n    // Copy the output indices into the wasm buffer, if needed\n    const outputsWasmArray = outputsWasmBuffer.getArrayView()\n    const outputsOffsetInBytes = runTimeLengthInBytes + inputsLengthInBytes\n    const outputsLengthInBytes = outputsWasmArray.byteLength\n    let useIndices = false\n    if (outputIndicesWasmBuffer) {\n      const indicesWasmArray = outputIndicesWasmBuffer.getArrayView()\n      const indicesLengthInElements = indicesWasmArray.length\n      const indicesOffsetInBytes = outputsOffsetInBytes + outputsLengthInBytes\n      const indicesBufferArray = new Int32Array(ioBuffer, indicesOffsetInBytes, indicesLengthInElements)\n      if (indicesBufferArray[0] !== 0) {\n        // Only use the indices if the first index is non-zero\n        indicesWasmArray.set(indicesBufferArray)\n        useIndices = true\n      }\n    }\n\n    // Run the model using the wasm buffers\n    const t0 = perfNow()\n    wasmModel.runModel(inputsWasmBuffer, outputsWasmBuffer, useIndices ? outputIndicesWasmBuffer : undefined)\n    const elapsed = perfElapsed(t0)\n\n    // Write the model run time to the buffer\n    const runTimeBufferArray = new Float64Array(ioBuffer, runTimeOffsetInBytes, runTimeLengthInElements)\n    runTimeBufferArray[0] = elapsed\n\n    // Copy the outputs from the wasm outputs buffer\n    const outputsLengthInElements = outputsWasmArray.length\n    const outputsBufferArray = new Float64Array(ioBuffer, outputsOffsetInBytes, outputsLengthInElements)\n    outputsBufferArray.set(outputsWasmArray)\n\n    // Transfer the buffer back to the runner\n    return Transfer(ioBuffer)\n  }\n}\n\n/**\n * Expose an object in the current worker thread that communicates with the\n * `ModelRunner` instance running in the main thread.  The exposed worker\n * object will take care of running the `WasmModel` on the worker thread\n * and sending the outputs back to the main process.\n *\n * @param init The function that initializes the `WasmModel` instance that\n * is used in the worker thread.\n */\nexport function exposeModelWorker(init: () => Promise<WasmModelInitResult>): void {\n  // Save the initializer, which will be used when the runner calls `initModel`\n  // on the worker\n  initWasmModel = init\n\n  // Expose the worker implementation to `threads.js`\n  expose(modelWorker)\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,oBAAiC;AAGjC,qBAAqC;AAGrC,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAEJ,IAAI;AAeJ,IAAM,cAAc;AAAA,EAClB,MAAM,YAAqD;AACzD,QAAI,WAAW;AACb,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACrD;AAGA,UAAM,aAAa,MAAM,cAAc;AAGvC,gBAAY,WAAW;AACvB,uBAAmB,WAAW;AAC9B,wBAAoB,WAAW;AAC/B,8BAA0B,WAAW;AAKrC,UAAM,gBAAgB;AACtB,UAAM,eAAe,iBAAiB,aAAa,EAAE;AACrD,UAAM,gBAAgB,kBAAkB,aAAa,EAAE;AACvD,UAAM,uBAAsB,mEAAyB,eAAe,WAAU;AAC9E,UAAM,cAAc,gBAAgB,eAAe,gBAAgB;AACnE,UAAM,UAAU,IAAI,aAAa,WAAW;AAG5C,UAAM,WAAW,QAAQ;AACzB,UAAM,aAAyB;AAAA,MAC7B,cAAc,WAAW;AAAA,MACzB,WAAW,UAAU;AAAA,MACrB,SAAS,UAAU;AAAA,MACnB,UAAU,UAAU;AAAA,MACpB;AAAA,MACA;AAAA,MACA;AAAA,MACA,iBAAiB,UAAU;AAAA,MAC3B;AAAA,IACF;AACA,eAAO,wBAAS,YAAY,CAAC,QAAQ,CAAC;AAAA,EACxC;AAAA,EAEA,SAAS,UAAwD;AAC/D,QAAI,CAAC,WAAW;AACd,YAAM,IAAI,MAAM,kEAAkE;AAAA,IACpF;AAGA,UAAM,uBAAuB;AAC7B,UAAM,0BAA0B;AAChC,UAAM,uBAAuB,0BAA0B;AAGvD,UAAM,kBAAkB,iBAAiB,aAAa;AACtD,UAAM,sBAAsB,uBAAuB;AACnD,UAAM,yBAAyB,gBAAgB;AAC/C,UAAM,sBAAsB,gBAAgB;AAC5C,UAAM,oBAAoB,IAAI,aAAa,UAAU,qBAAqB,sBAAsB;AAChG,oBAAgB,IAAI,iBAAiB;AAGrC,UAAM,mBAAmB,kBAAkB,aAAa;AACxD,UAAM,uBAAuB,uBAAuB;AACpD,UAAM,uBAAuB,iBAAiB;AAC9C,QAAI,aAAa;AACjB,QAAI,yBAAyB;AAC3B,YAAM,mBAAmB,wBAAwB,aAAa;AAC9D,YAAM,0BAA0B,iBAAiB;AACjD,YAAM,uBAAuB,uBAAuB;AACpD,YAAM,qBAAqB,IAAI,WAAW,UAAU,sBAAsB,uBAAuB;AACjG,UAAI,mBAAmB,OAAO,GAAG;AAE/B,yBAAiB,IAAI,kBAAkB;AACvC,qBAAa;AAAA,MACf;AAAA,IACF;AAGA,UAAM,SAAK,wBAAQ;AACnB,cAAU,SAAS,kBAAkB,mBAAmB,aAAa,0BAA0B,MAAS;AACxG,UAAM,cAAU,4BAAY,EAAE;AAG9B,UAAM,qBAAqB,IAAI,aAAa,UAAU,sBAAsB,uBAAuB;AACnG,uBAAmB,KAAK;AAGxB,UAAM,0BAA0B,iBAAiB;AACjD,UAAM,qBAAqB,IAAI,aAAa,UAAU,sBAAsB,uBAAuB;AACnG,uBAAmB,IAAI,gBAAgB;AAGvC,eAAO,wBAAS,QAAQ;AAAA,EAC1B;AACF;AAWO,SAAS,kBAAkB,MAAgD;AAGhF,kBAAgB;AAGhB,4BAAO,WAAW;AACpB;","names":[]}