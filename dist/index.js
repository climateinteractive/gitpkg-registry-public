// src/plugin.ts
import { basename, dirname as dirname2, join as joinPath } from "path";
import { build } from "vite";

// src/vite-config.ts
import { dirname, resolve as resolvePath } from "path";
import { fileURLToPath } from "url";

// src/var-names.ts
function sdeNameForVensimName(name) {
  return "_" + name.trim().replace(/"/g, "_").replace(/\s+!$/g, "!").replace(/\s/g, "_").replace(/,/g, "_").replace(/-/g, "_").replace(/\./g, "_").replace(/\$/g, "_").replace(/'/g, "_").replace(/&/g, "_").replace(/%/g, "_").replace(/\//g, "_").replace(/\|/g, "_").toLowerCase();
}
function sdeNameForVensimVarName(varName) {
  const m = varName.match(/([^[]+)(?:\[([^\]]+)\])?/);
  if (!m) {
    throw new Error(`Invalid Vensim name: ${varName}`);
  }
  let id = sdeNameForVensimName(m[1]);
  if (m[2]) {
    const subscripts = m[2].split(",").map((x) => sdeNameForVensimName(x));
    id += `[${subscripts.join("][")}]`;
  }
  return id;
}

// src/vite-config.ts
var __filename2 = fileURLToPath(import.meta.url);
var __dirname2 = dirname(__filename2);
function injectModelSpec(modelSpec) {
  const outputVarIds = modelSpec.outputs.map((o) => sdeNameForVensimVarName(o.varName));
  const moduleSrc = `
export const numInputs = ${modelSpec.inputs.length};
export const outputVarIds = ${JSON.stringify(outputVarIds)};
`;
  const virtualModuleId = "virtual:model-spec";
  const resolvedVirtualModuleId = "\0" + virtualModuleId;
  return {
    name: "vite-plugin-virtual-custom",
    resolveId(id) {
      if (id === virtualModuleId) {
        return resolvedVirtualModuleId;
      }
    },
    load(id) {
      if (id === resolvedVirtualModuleId) {
        return moduleSrc;
      }
    }
  };
}
function createViteConfig(stagedModelDir, modelJsFile, modelSpec, outputFile) {
  const root = stagedModelDir;
  const entry = resolvePath(__dirname2, "..", "template-worker", "worker.js");
  return {
    // Don't use an external config file
    configFile: false,
    // Use the root directory configured above
    root,
    // Don't clear the screen in dev mode so that we can see builder output
    clearScreen: false,
    // Disable vite output by default
    // TODO: Re-enable logging if `--verbose` option is used?
    logLevel: "silent",
    // Configure path aliases
    resolve: {
      alias: [
        // In the template, we use `@_wasm_` as an alias for the JS-wrapped Wasm
        // file generated by Emscripten
        {
          find: "@_wasm_",
          replacement: resolvePath(stagedModelDir, modelJsFile)
        }
      ],
      // XXX: Prevent Vite from using the `browser` section of `threads/package.json`
      // since we want to force the use of the general module (under dist) that chooses
      // the correct implementation (Web Worker vs worker_threads) at runtime.  This
      // gets the job done, but is fragile because it applies to all dependencies even
      // though we really only need this workaround for the threads package.  Fortunately
      // the worker template is very simple (only depends on `@sdeverywhere/runtime-async`,
      // which in turn only depends on `@sdeverywhere/runtime` and `threads`, so we should
      // be safe to use this workaround for a while.
      browserField: false
    },
    plugins: [
      // Use a virtual module plugin to inject the model spec values
      injectModelSpec(modelSpec)
    ],
    build: {
      // Write output file to the `staged/model` directory; note that this path is
      // relative to the bundle `root` directory
      outDir: ".",
      emptyOutDir: false,
      lib: {
        entry,
        name: "worker",
        formats: ["iife"],
        fileName: () => outputFile
      },
      rollupOptions: {
        onwarn: (warning, warn) => {
          if (warning.code !== "EVAL") {
            warn(warning);
          }
        }
      }
    }
  };
}

// src/plugin.ts
function workerPlugin(options) {
  return new WorkerPlugin(options);
}
var WorkerPlugin = class {
  constructor(options) {
    this.options = options;
  }
  async postGenerate(context, modelSpec) {
    const log = context.log;
    log("info", "Building worker");
    const prepDir = context.config.prepDir;
    const srcDir = "model";
    const stagedModelDir = joinPath(prepDir, "staged", srcDir);
    const inModelJsFile = "wasm-model.js";
    const outWorkerJsFile = "worker.js";
    const outputPaths = this.options?.outputPaths || [joinPath(prepDir, outWorkerJsFile)];
    for (const outputPath of outputPaths) {
      const dstDir = dirname2(outputPath);
      const dstFile = basename(outputPath);
      context.prepareStagedFile(srcDir, outWorkerJsFile, dstDir, dstFile);
    }
    const viteConfig = createViteConfig(stagedModelDir, inModelJsFile, modelSpec, outWorkerJsFile);
    await build(viteConfig);
    return true;
  }
};
export {
  workerPlugin
};
//# sourceMappingURL=index.js.map